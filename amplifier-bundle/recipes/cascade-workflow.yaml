name: "cascade-workflow"
description: "Graceful degradation workflow with 3-level fallback cascade (PRIMARY → SECONDARY → TERTIARY)"
version: "1.0.0"
author: "Amplihack Team"
tags: ["resilience", "fallback", "degradation", "reliability", "cascade"]

# CASCADE_WORKFLOW: Graceful Degradation with 3-Level Fallback
#
# This recipe implements a robust cascade pattern ensuring task completion
# through progressive degradation:
#
#   PRIMARY   → Best outcome, may depend on external services, can fail/timeout
#   SECONDARY → Reduced quality but functional, more reliable, faster
#   TERTIARY  → Always succeeds, never fails, no external deps, minimal but works
#
# The TERTIARY level is GUARANTEED to complete - it has no external dependencies
# and uses only local, deterministic operations.
#
# Timeout Strategies:
#   aggressive: 5s / 2s / 1s   (fast fail, quick degradation)
#   balanced:   30s / 10s / 5s (default - reasonable for most tasks)
#   patient:    120s / 30s / 10s (wait longer before degrading)
#
# Notification Modes:
#   silent:   Log only, no user notification
#   warning:  Brief notification of degradation
#   explicit: Detailed explanation of what degraded and why
#
# Usage:
#   amplifier recipes execute cascade-workflow.yaml --context '{
#     "task_description": "Fetch user data from API",
#     "primary_approach": "Call external user service API",
#     "secondary_approach": "Use cached user data from local store",
#     "tertiary_approach": "Return minimal stub user object",
#     "timeout_strategy": "balanced",
#     "notification_mode": "warning"
#   }'

recursion:
  max_depth: 3
  max_total_steps: 25

context:
  # Task configuration (required)
  task_description: ""
  primary_approach: ""
  secondary_approach: ""
  tertiary_approach: ""
  
  # Timeout strategy: aggressive, balanced, patient
  timeout_strategy: "balanced"
  
  # Notification mode: silent, warning, explicit
  notification_mode: "warning"
  
  # Working directory for metrics and state
  working_dir: "./ai_working/cascade"
  
  # Session identifier for metrics correlation
  session_id: ""
  
  # Exit code tracking (set by output_exit_code, need defaults for validator)
  primary_exit_code: "1"
  secondary_exit_code: "1"
  
  # Result tracking (set by conditional steps, need defaults for templates)
  secondary_result: ""
  tertiary_result: ""

steps:
  # ==========================================================================
  # STEP 1: CASCADE LEVEL DEFINITION
  # Define the three cascade levels with their characteristics and timeouts
  # ==========================================================================
  - id: "cascade-level-definition"
    type: "bash"
    parse_json: true
    command: |
      set -euo pipefail
      
      # Validate inputs - reject dangerous patterns
      WORKING_DIR='{{working_dir}}'
      TIMEOUT_STRATEGY='{{timeout_strategy}}'
      case "$WORKING_DIR" in
        *'$('*|*'`'*|*';'*|*'|'*|*'&'*)
          echo '{"error": "Invalid characters in working_dir"}' && exit 1 ;;
      esac
      mkdir -p "$WORKING_DIR"
      
      # Define timeout values based on strategy
      case "$TIMEOUT_STRATEGY" in
        aggressive)
          PRIMARY_TIMEOUT=5
          SECONDARY_TIMEOUT=2
          TERTIARY_TIMEOUT=1
          ;;
        patient)
          PRIMARY_TIMEOUT=120
          SECONDARY_TIMEOUT=30
          TERTIARY_TIMEOUT=10
          ;;
        balanced|*)
          PRIMARY_TIMEOUT=30
          SECONDARY_TIMEOUT=10
          TERTIARY_TIMEOUT=5
          ;;
      esac
      
      # Generate session ID if not provided (use single quotes for safety)
      SESSION_ID='{{session_id}}'
      if [ -z "$SESSION_ID" ]; then
        SESSION_ID="cascade_$(date +%Y%m%d_%H%M%S)_$$"
      fi
      
      # Output cascade configuration as JSON
      cat << EOF
      {
        "session_id": "$SESSION_ID",
        "strategy": "{{timeout_strategy}}",
        "levels": {
          "PRIMARY": {
            "name": "PRIMARY",
            "description": "Optimal solution - best quality, may have external dependencies",
            "timeout_seconds": $PRIMARY_TIMEOUT,
            "can_fail": true,
            "approach": "{{primary_approach}}"
          },
          "SECONDARY": {
            "name": "SECONDARY",
            "description": "Acceptable degradation - reduced quality but functional",
            "timeout_seconds": $SECONDARY_TIMEOUT,
            "can_fail": true,
            "approach": "{{secondary_approach}}"
          },
          "TERTIARY": {
            "name": "TERTIARY",
            "description": "Guaranteed completion - minimal but always works",
            "timeout_seconds": $TERTIARY_TIMEOUT,
            "can_fail": false,
            "approach": "{{tertiary_approach}}"
          }
        },
        "task": "{{task_description}}",
        "started_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
      }
      EOF
    output: "cascade_config"
    timeout: 30

  # ==========================================================================
  # STEP 2: PRIMARY ATTEMPT
  # Execute the optimal solution with timeout protection
  # ==========================================================================
  - id: "primary-attempt"
    agent: "foundation:zen-architect"
    mode: "EXECUTE"
    prompt: |
      Execute the PRIMARY level approach for the cascade workflow.

      **Task**: {{task_description}}
      **Approach**: {{primary_approach}}
      **Timeout**: This attempt has a strict timeout - work efficiently.

      **Cascade Context**:
      {{cascade_config}}

      **Instructions**:
      1. Attempt the PRIMARY approach as specified
      2. This is the optimal/best-quality solution path
      3. External dependencies are allowed at this level
      4. If successful, report completion with full results
      5. If any issues arise, report them clearly for fallback handling

      **Output Requirements**:
      - Report: SUCCESS or FAILURE
      - If SUCCESS: Include full results/output
      - If FAILURE: Include error details and reason for failure
      - Include execution time estimate

      Attempt the PRIMARY approach now.
    output: "primary_result"
    timeout: 120
    on_error: "continue"
    output_exit_code: "primary_exit_code"

  # ==========================================================================
  # STEP 3: EVALUATE PRIMARY & TRIGGER SECONDARY IF NEEDED
  # ==========================================================================
  - id: "evaluate-primary"
    type: "bash"
    parse_json: true
    command: |
      # Check if primary succeeded
      PRIMARY_EXIT="${{primary_exit_code}}"
      
      # Use heredoc to safely handle result text with special characters
      cat << 'PRIMARY_EOF' > /tmp/primary_result_$$.txt
      {{primary_result}}
      PRIMARY_EOF
      
      # Check for success indicators in the result
      if [ "$PRIMARY_EXIT" = "0" ] && grep -qi "SUCCESS" /tmp/primary_result_$$.txt 2>/dev/null; then
        echo '{"primary_succeeded": true, "cascade_level": "PRIMARY", "needs_fallback": false}'
      else
        echo '{"primary_succeeded": false, "cascade_level": "PRIMARY", "needs_fallback": true, "fallback_reason": "Primary attempt failed or timed out"}'
      fi
      rm -f /tmp/primary_result_$$.txt
    output: "primary_evaluation"
    timeout: 30

  # ==========================================================================
  # STEP 4: SECONDARY FALLBACK
  # Execute if primary failed - reduced quality but more reliable
  # ==========================================================================
  - id: "secondary-fallback"
    agent: "foundation:zen-architect"
    mode: "EXECUTE"
    condition: "{{primary_evaluation.needs_fallback}}"
    prompt: |
      Execute the SECONDARY level fallback for the cascade workflow.

      **Task**: {{task_description}}
      **Approach**: {{secondary_approach}}
      **Reason for Fallback**: Primary attempt failed or timed out

      **Primary Attempt Result**:
      {{primary_result}}

      **Cascade Context**:
      {{cascade_config}}

      **Instructions**:
      1. Execute the SECONDARY approach as specified
      2. This is an acceptable degradation - prioritize reliability over quality
      3. Should be faster and more reliable than PRIMARY
      4. Avoid external dependencies where possible
      5. If successful, report completion with results
      6. If any issues arise, report them for TERTIARY fallback

      **Output Requirements**:
      - Report: SUCCESS or FAILURE
      - If SUCCESS: Include results (may be reduced quality)
      - If FAILURE: Include error details
      - Note any degradation from optimal outcome

      Attempt the SECONDARY approach now.
    output: "secondary_result"
    timeout: 60
    on_error: "continue"
    output_exit_code: "secondary_exit_code"

  # ==========================================================================
  # STEP 5: EVALUATE SECONDARY & TRIGGER TERTIARY IF NEEDED
  # ==========================================================================
  - id: "evaluate-secondary"
    type: "bash"
    parse_json: true
    command: |
      # Check if we even needed secondary
      cat << 'EVAL_EOF' > /tmp/primary_eval_$$.txt
      {{primary_evaluation}}
      EVAL_EOF
      
      NEEDS_FALLBACK=$(cat /tmp/primary_eval_$$.txt | grep -o '"needs_fallback":\s*\w*' | grep -o 'true\|false' || echo "false")
      rm -f /tmp/primary_eval_$$.txt
      
      if [ "$NEEDS_FALLBACK" != "true" ]; then
        # Primary succeeded, no secondary was run
        echo '{"cascade_level": "PRIMARY", "secondary_run": false, "needs_tertiary": false, "final_level": "PRIMARY"}'
        exit 0
      fi
      
      # Secondary was run, check its result
      SECONDARY_EXIT="{{secondary_exit_code}}"
      
      cat << 'SECONDARY_EOF' > /tmp/secondary_result_$$.txt
      {{secondary_result}}
      SECONDARY_EOF
      
      if [ "$SECONDARY_EXIT" = "0" ] && grep -qi "SUCCESS" /tmp/secondary_result_$$.txt 2>/dev/null; then
        echo '{"cascade_level": "SECONDARY", "secondary_run": true, "secondary_succeeded": true, "needs_tertiary": false, "final_level": "SECONDARY"}'
      else
        echo '{"cascade_level": "SECONDARY", "secondary_run": true, "secondary_succeeded": false, "needs_tertiary": true, "fallback_reason": "Secondary attempt failed"}'
      fi
      rm -f /tmp/secondary_result_$$.txt
    output: "secondary_evaluation"
    timeout: 30

  # ==========================================================================
  # STEP 6: TERTIARY GUARANTEE
  # Execute if secondary failed - MUST ALWAYS SUCCEED
  # This level has NO external dependencies and uses only deterministic operations
  # ==========================================================================
  - id: "tertiary-guarantee"
    agent: "foundation:zen-architect"
    mode: "EXECUTE"
    condition: "{{secondary_evaluation.needs_tertiary}}"
    prompt: |
      Execute the TERTIARY level GUARANTEED completion for the cascade workflow.

      **CRITICAL**: This level MUST SUCCEED. Failure is NOT an option.

      **Task**: {{task_description}}
      **Approach**: {{tertiary_approach}}
      **Reason**: Both PRIMARY and SECONDARY approaches failed

      **Previous Attempts**:
      - PRIMARY: {{primary_result}}
      - SECONDARY: {{secondary_result}}

      **Cascade Context**:
      {{cascade_config}}

      **TERTIARY LEVEL RULES**:
      1. NO external dependencies allowed
      2. NO network calls
      3. NO operations that can fail due to external factors
      4. Use ONLY local, deterministic operations
      5. Return minimal but FUNCTIONAL output
      6. This is a GUARANTEE - you MUST produce usable output

      **Instructions**:
      1. Execute the TERTIARY approach exactly as specified
      2. If the specified approach cannot guarantee success, create a minimal stub
      3. Output MUST be usable by downstream consumers
      4. Prioritize completion over quality
      5. Document what was degraded/omitted

      **Output Requirements**:
      - Report: SUCCESS (this MUST succeed)
      - Include minimal but functional results
      - List what functionality was degraded
      - Explain what the minimal output provides

      Execute the TERTIARY guaranteed completion now. YOU MUST SUCCEED.
    output: "tertiary_result"
    timeout: 30
    retry:
      max_attempts: 3
      backoff: "linear"
      initial_delay: 1

  # ==========================================================================
  # STEP 7: DETERMINE FINAL CASCADE LEVEL
  # ==========================================================================
  - id: "determine-final-level"
    type: "bash"
    parse_json: true
    command: |
      # Determine which level ultimately succeeded
      cat << 'SEC_EVAL_EOF' > /tmp/sec_eval_$$.txt
      {{secondary_evaluation}}
      SEC_EVAL_EOF
      
      NEEDS_TERTIARY=$(cat /tmp/sec_eval_$$.txt | grep -o '"needs_tertiary":\s*\w*' | grep -o 'true\|false' || echo "false")
      SECONDARY_RUN=$(cat /tmp/sec_eval_$$.txt | grep -o '"secondary_run":\s*\w*' | grep -o 'true\|false' || echo "false")
      rm -f /tmp/sec_eval_$$.txt
      
      if [ "$NEEDS_TERTIARY" = "true" ]; then
        FINAL_LEVEL="TERTIARY"
        DEGRADATION="maximum"
      elif [ "$SECONDARY_RUN" = "true" ]; then
        FINAL_LEVEL="SECONDARY"
        DEGRADATION="moderate"
      else
        FINAL_LEVEL="PRIMARY"
        DEGRADATION="none"
      fi
      
      cat << EOF
      {
        "final_level": "$FINAL_LEVEL",
        "degradation": "$DEGRADATION",
        "completed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
      }
      EOF
    output: "final_level_info"
    timeout: 30

  # ==========================================================================
  # STEP 8: DEGRADATION REPORTING
  # Inform user of achieved cascade level based on notification mode
  # ==========================================================================
  - id: "degradation-reporting"
    type: "bash"
    command: |
      # Use single quotes for safety against command injection
      FINAL_LEVEL='{{final_level_info.final_level}}'
      DEGRADATION='{{final_level_info.degradation}}'
      NOTIFICATION_MODE='{{notification_mode}}'
      
      # Build report based on notification mode
      case "$NOTIFICATION_MODE" in
        silent)
          # Log only, minimal output
          echo "[CASCADE] Completed at $FINAL_LEVEL level (degradation: $DEGRADATION)"
          ;;
        warning)
          # Brief notification
          if [ "$FINAL_LEVEL" = "PRIMARY" ]; then
            echo "✓ Task completed successfully at optimal quality"
          elif [ "$FINAL_LEVEL" = "SECONDARY" ]; then
            echo "⚠ Task completed with reduced quality (SECONDARY fallback used)"
            echo "  Reason: Primary approach failed or timed out"
          else
            echo "⚠ Task completed with minimal functionality (TERTIARY fallback used)"
            echo "  Reason: Both PRIMARY and SECONDARY approaches failed"
            echo "  Note: Output is functional but degraded"
          fi
          ;;
        explicit|*)
          # Detailed explanation
          echo "═══════════════════════════════════════════════════════════════"
          echo "CASCADE WORKFLOW COMPLETION REPORT"
          echo "═══════════════════════════════════════════════════════════════"
          echo ""
          echo "Task: {{task_description}}"
          echo "Strategy: {{timeout_strategy}}"
          echo "Final Level: $FINAL_LEVEL"
          echo "Degradation: $DEGRADATION"
          echo ""
          echo "CASCADE PATH:"
          if [ "$FINAL_LEVEL" = "PRIMARY" ]; then
            echo "  [✓] PRIMARY  → Success (optimal outcome)"
            echo "  [ ] SECONDARY → Not needed"
            echo "  [ ] TERTIARY  → Not needed"
          elif [ "$FINAL_LEVEL" = "SECONDARY" ]; then
            echo "  [✗] PRIMARY  → Failed/Timeout"
            echo "  [✓] SECONDARY → Success (acceptable degradation)"
            echo "  [ ] TERTIARY  → Not needed"
          else
            echo "  [✗] PRIMARY  → Failed/Timeout"
            echo "  [✗] SECONDARY → Failed/Timeout"
            echo "  [✓] TERTIARY  → Guaranteed completion"
          fi
          echo ""
          echo "═══════════════════════════════════════════════════════════════"
          ;;
      esac
    output: "degradation_report"
    timeout: 30

  # ==========================================================================
  # STEP 9: METRICS LOGGING
  # Record cascade path and timing for optimization analysis
  # ==========================================================================
  - id: "metrics-logging"
    type: "bash"
    parse_json: true
    command: |
      set -euo pipefail
      
      # Validate working_dir and use single quotes for safety
      WORKING_DIR='{{working_dir}}'
      case "$WORKING_DIR" in
        *'$('*|*'`'*|*';'*|*'|'*|*'&'*)
          echo '{"error": "Invalid characters in working_dir"}' && exit 1 ;;
      esac
      METRICS_FILE="$WORKING_DIR/cascade_metrics.jsonl"
      
      # Extract session ID from config
      cat << 'CONFIG_EOF' > /tmp/cascade_config_$$.txt
      {{cascade_config}}
      CONFIG_EOF
      SESSION_ID=$(grep -o '"session_id":\s*"[^"]*"' /tmp/cascade_config_$$.txt | sed 's/.*"\([^"]*\)"$/\1/' || echo "unknown")
      STARTED_AT=$(grep -o '"started_at":\s*"[^"]*"' /tmp/cascade_config_$$.txt | sed 's/.*"\([^"]*\)"$/\1/' || echo "unknown")
      rm -f /tmp/cascade_config_$$.txt
      
      # Use single quotes for safety
      COMPLETED_AT='{{final_level_info.completed_at}}'
      FINAL_LEVEL='{{final_level_info.final_level}}'
      
      # Create metrics entry
      METRICS_ENTRY=$(cat << EOF
      {"session_id": "$SESSION_ID", "task": "{{task_description}}", "strategy": "{{timeout_strategy}}", "final_level": "$FINAL_LEVEL", "degradation": "{{final_level_info.degradation}}", "started_at": "$STARTED_AT", "completed_at": "$COMPLETED_AT", "notification_mode": "{{notification_mode}}"}
      EOF
      )
      
      # Append to metrics log
      echo "$METRICS_ENTRY" >> "$METRICS_FILE"
      
      # Output metrics summary
      cat << EOF
      {
        "metrics_logged": true,
        "metrics_file": "$METRICS_FILE",
        "session_id": "$SESSION_ID",
        "cascade_path": "$FINAL_LEVEL",
        "optimization_hint": $(
          if [ "$FINAL_LEVEL" = "TERTIARY" ]; then
            echo '"Consider increasing timeouts or improving PRIMARY/SECONDARY approaches"'
          elif [ "$FINAL_LEVEL" = "SECONDARY" ]; then
            echo '"Monitor PRIMARY success rate - may need adjustment"'
          else
            echo '"Cascade performing optimally"'
          fi
        )
      }
      EOF
    output: "metrics_result"
    timeout: 30

  # ==========================================================================
  # STEP 10: CONTINUOUS OPTIMIZATION RECOMMENDATIONS
  # Analyze historical metrics and suggest timeout adjustments
  # ==========================================================================
  - id: "continuous-optimization"
    type: "bash"
    parse_json: true
    command: |
      set -euo pipefail
      
      # Validate working_dir and use single quotes for safety
      WORKING_DIR='{{working_dir}}'
      case "$WORKING_DIR" in
        *'$('*|*'`'*|*';'*|*'|'*|*'&'*)
          echo '{"error": "Invalid characters in working_dir"}' && exit 1 ;;
      esac
      METRICS_FILE="$WORKING_DIR/cascade_metrics.jsonl"
      
      # Check if we have enough data for analysis
      if [ ! -f "$METRICS_FILE" ]; then
        echo '{"has_recommendations": false, "reason": "No historical data yet"}'
        exit 0
      fi
      
      TOTAL_RUNS=$(wc -l < "$METRICS_FILE" | tr -d ' ')
      
      if [ "$TOTAL_RUNS" -lt 5 ]; then
        echo "{\"has_recommendations\": false, \"reason\": \"Insufficient data - need 5+ runs, have $TOTAL_RUNS\"}"
        exit 0
      fi
      
      # Analyze cascade patterns
      PRIMARY_COUNT=$(grep -c '"final_level":\s*"PRIMARY"' "$METRICS_FILE" || echo 0)
      SECONDARY_COUNT=$(grep -c '"final_level":\s*"SECONDARY"' "$METRICS_FILE" || echo 0)
      TERTIARY_COUNT=$(grep -c '"final_level":\s*"TERTIARY"' "$METRICS_FILE" || echo 0)
      
      # Calculate percentages
      PRIMARY_PCT=$((PRIMARY_COUNT * 100 / TOTAL_RUNS))
      SECONDARY_PCT=$((SECONDARY_COUNT * 100 / TOTAL_RUNS))
      TERTIARY_PCT=$((TERTIARY_COUNT * 100 / TOTAL_RUNS))
      
      # Generate recommendations
      RECOMMENDATIONS="[]"
      
      if [ "$TERTIARY_PCT" -gt 30 ]; then
        RECOMMENDATIONS="[\"High TERTIARY rate (${TERTIARY_PCT}%) - consider 'patient' timeout strategy\", \"Review PRIMARY approach reliability\"]"
      elif [ "$SECONDARY_PCT" -gt 50 ]; then
        RECOMMENDATIONS="[\"Frequent SECONDARY fallback (${SECONDARY_PCT}%) - consider increasing PRIMARY timeout\"]"
      elif [ "$PRIMARY_PCT" -gt 90 ]; then
        RECOMMENDATIONS="[\"Excellent PRIMARY success rate (${PRIMARY_PCT}%) - consider 'aggressive' strategy for faster failures\"]"
      fi
      
      cat << EOF
      {
        "has_recommendations": true,
        "total_runs_analyzed": $TOTAL_RUNS,
        "distribution": {
          "PRIMARY": {"count": $PRIMARY_COUNT, "percentage": $PRIMARY_PCT},
          "SECONDARY": {"count": $SECONDARY_COUNT, "percentage": $SECONDARY_PCT},
          "TERTIARY": {"count": $TERTIARY_COUNT, "percentage": $TERTIARY_PCT}
        },
        "recommendations": $RECOMMENDATIONS,
        "current_strategy": "{{timeout_strategy}}",
        "suggested_strategy": $(
          if [ "$TERTIARY_PCT" -gt 30 ]; then
            echo '"patient"'
          elif [ "$PRIMARY_PCT" -gt 90 ]; then
            echo '"aggressive"'
          else
            echo '"balanced"'
          fi
        )
      }
      EOF
    output: "optimization_result"
    timeout: 60

  # ==========================================================================
  # STEP 11: FINAL OUTPUT ASSEMBLY
  # Compile final result from whichever cascade level succeeded
  # ==========================================================================
  - id: "assemble-final-output"
    type: "bash"
    command: |
      # Use single quotes for safety
      FINAL_LEVEL='{{final_level_info.final_level}}'
      
      echo "═══════════════════════════════════════════════════════════════"
      echo "CASCADE WORKFLOW COMPLETE"
      echo "═══════════════════════════════════════════════════════════════"
      echo ""
      echo "Final Level: $FINAL_LEVEL"
      echo "Task: {{task_description}}"
      echo ""
      echo "RESULT:"
      echo "-------"
      
      case "$FINAL_LEVEL" in
        PRIMARY)
          cat << 'RESULT_EOF'
      {{primary_result}}
      RESULT_EOF
          ;;
        SECONDARY)
          cat << 'RESULT_EOF'
      {{secondary_result}}
      RESULT_EOF
          ;;
        TERTIARY)
          cat << 'RESULT_EOF'
      {{tertiary_result}}
      RESULT_EOF
          ;;
      esac
      
      echo ""
      echo "═══════════════════════════════════════════════════════════════"
      echo "Optimization Insights:"
      echo "{{optimization_result}}"
      echo "═══════════════════════════════════════════════════════════════"
    output: "final_output"
    timeout: 30

# Expected workflow execution:
#
# 1. cascade-level-definition → Configures timeouts and session
# 2. primary-attempt → Tries optimal solution
# 3. evaluate-primary → Checks if fallback needed
# 4. secondary-fallback → (conditional) Tries degraded solution
# 5. evaluate-secondary → Checks if tertiary needed
# 6. tertiary-guarantee → (conditional) ALWAYS succeeds
# 7. determine-final-level → Identifies which level completed
# 8. degradation-reporting → Informs user appropriately
# 9. metrics-logging → Records for analysis
# 10. continuous-optimization → Suggests improvements
# 11. assemble-final-output → Returns final result
#
# GUARANTEE: The workflow ALWAYS completes. TERTIARY level cannot fail.
